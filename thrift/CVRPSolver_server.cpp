// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "CVRPSolver.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include "../main.h"
#include "../utils.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;
using namespace operations_research;

using boost::shared_ptr;

class CVRPSolverHandler : virtual public CVRPSolverIf {
 public:
  CVRPSolverHandler() {
    // Your initialization goes here
  }

  void solveCVRP(std::vector<std::vector<int64_t> > & _return, const std::vector<std::vector<int64_t> > & vec, const std::vector<int64_t> & demands, const std::vector<int64_t> & v_caps) {
    // Your implementation goes here
    printf("solveCVRP\n");
  }

  void solveCVRPTW(std::vector<std::vector<int64_t> > & _return, const std::vector<std::vector<int64_t> > & vec, const std::vector<int64_t> & demands, const std::vector<int64_t> & v_caps, const std::vector<std::vector<int64_t> > & timeWindows, const std::vector<int64_t> & serviceTime, const std::vector<std::vector<int64_t> > & vehWindows) {


    Utils utils;

    int size = vec.size();
    int demandSize  = demands.size();
    int servTimes = serviceTime.size();

    std::vector<long long int> v2 (size, 0);
    std::vector<long long int> dem (demandSize, 0);
    std::vector<long long int> veh_caps(v_caps.size(),0);
    std::vector<long long int > sTime(servTimes, 0);

    std::vector<std::vector<long long int>> tempVec(size, v2);

    for(int i=0; i< tempVec.size(); i++) {
      for (int j=0;j<tempVec[i].size(); j++){

        tempVec[i][j] = (long long int) vec[i][j];
        // std::cout << tempVec[i][j] << " ";
      }
      // std::cout << std::endl;
    }


    for(int i=0; i< demandSize; i++) {

      dem[i] = demands[i];
    }


    for(int i=0; i< v_caps.size(); i++) {

      veh_caps[i] = v_caps[i];
    }


    for(int i=0; i< servTimes; i++) {

      sTime[i] = serviceTime[i] ;
      //
      // std::cout <<  sTime[i] << std::endl;
    }



    // std::vector<std::vector<int64>> tempVec = utils.cast2dList(vec);
    // std::vector<int64> dem = utils.castList(demands);
    // std::vector<int64> veh_caps = utils.castList(v_caps);


    std::vector<std::pair<int64, int64>> timeW = utils.castToListOfPairs(timeWindows);
    std::vector<std::pair<int64, int64>> vWindows = utils.castToListOfPairs(vehWindows);
    // std::vector<int64> servTime = utils.castList(serviceTime);

    operations_research::Matrix matrix(tempVec, dem, veh_caps, timeW, sTime, vWindows);
    operations_research::CVRPTWSolver vrpSolver;

    std::vector<std::vector<int64>> cvrp_result = vrpSolver.SolveCVRPTW(matrix, veh_caps.size());

    for(int i=0; i< cvrp_result.size(); i++) {

      _return.push_back(std::vector<int64_t>(0,0));
      for (int j = 0; j < cvrp_result[i].size(); j++){

        _return[i].push_back((int64_t) cvrp_result[i][j]);
      }
    }

    printf("solveCVRPTW\n");
  }

  void solveCVRPTWMD(std::vector<std::vector<int64_t> > & _return, const std::vector<std::vector<int64_t> > & vec, const std::vector<int64_t> & demands, const std::vector<int64_t> & v_caps, const std::vector<std::vector<int64_t> > & timeWindows, const std::vector<int64_t> & serviceTime, const std::vector<std::vector<int64_t> > & depots) {
    // Your implementation goes here
    printf("solveCVRPTWMD\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<CVRPSolverHandler> handler(new CVRPSolverHandler());
//  shared_ptr<TProcessor> processor(new CVRPSolverProcessor(handler));
//  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
//  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
//  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
//
//  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
//  server.serve();

      //NONBLOCKING SERVER
    shared_ptr<TProcessor> processor(new CVRPSolverProcessor(handler));
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    // using thread pool with maximum 15 threads to handle incoming requests
    shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(15);
    shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();
    TNonblockingServer server(processor, protocolFactory, port, threadManager);
    server.serve();


  return 0;
}

